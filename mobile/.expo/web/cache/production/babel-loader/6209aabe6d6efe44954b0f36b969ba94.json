{"ast":null,"code":"import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";var _excluded=[\"children\"],_excluded2=[\"focusable\",\"stroke\",\"color\",\"size\"];function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}import React,{memo,forwardRef}from'react';import{useToken,usePropsResolution}from\"../../../hooks\";import{makeStyledComponent}from\"../../../utils/styled\";import{Svg,G}from\"./nbSvg\";import{questionOutlineIconPath}from\"./Icons/questionIconPath\";import{useHasResponsiveProps}from\"../../../hooks/useHasResponsiveProps\";var SVG=makeStyledComponent(Svg);var SVGIcon=function SVGIcon(_ref,ref){var children=_ref.children,props=_objectWithoutProperties(_ref,_excluded);var _usePropsResolution=usePropsResolution('Icon',props),focusable=_usePropsResolution.focusable,stroke=_usePropsResolution.stroke,color=_usePropsResolution.color,size=_usePropsResolution.size,resolvedProps=_objectWithoutProperties(_usePropsResolution,_excluded2);var strokeHex=useToken('colors',stroke||'');var colorHex=useToken('colors',color||'');if(useHasResponsiveProps(props)){return null;}return React.createElement(SVG,_extends({},resolvedProps,{size:size,color:colorHex,stroke:strokeHex,focusable:focusable,accessibilityRole:\"image\",ref:ref}),React.Children.count(children)>0?React.createElement(G,null,React.Children.map(children,function(child,i){var _child$key;return React.createElement(ChildPath,_extends({key:(_child$key=child===null||child===void 0?void 0:child.key)!==null&&_child$key!==void 0?_child$key:i,element:child},child===null||child===void 0?void 0:child.props));})):questionOutlineIconPath);};var ChildPath=function ChildPath(_ref2){var element=_ref2.element,fill=_ref2.fill,pathStroke=_ref2.stroke;var pathStrokeColor=useToken('colors',pathStroke||'');var fillColor=useToken('colors',fill||'');if(!element){return null;}return React.cloneElement(element,{fill:fillColor?fillColor:'currentColor',stroke:pathStrokeColor});};export default memo(forwardRef(SVGIcon));","map":{"version":3,"mappings":"wbAAA,MAAOA,MAAP,EAAgBC,IAAhB,CAAsBC,UAAtB,KAAwC,OAAxC,CACA,OAASC,QAAT,CAAmBC,kBAAnB,sBACA,OAASC,mBAAT,6BACA,OAASC,GAAT,CAAcC,CAAd,eAEA,OAASC,uBAAT,gCACA,OAASC,qBAAT,4CAEA,GAAMC,IAAG,CAAGL,mBAAmB,CAACC,GAAD,CAA/B,CAEA,GAAMK,QAAO,CAAG,QAAVA,QAAU,MAAqCC,GAArC,CAAkD,IAA/CC,SAA+C,MAA/CA,QAA+C,CAAlCC,KAAkC,0CAChE,wBAMIV,kBAAkB,CAAC,MAAD,CAASU,KAAT,CANtB,CACEC,SADF,qBACEA,SADF,CAEEC,MAFF,qBAEEA,MAFF,CAGEC,KAHF,qBAGEA,KAHF,CAIEC,IAJF,qBAIEA,IAJF,CAKKC,aALL,0DAOA,GAAMC,UAAS,CAAGjB,QAAQ,CAAC,QAAD,CAAWa,MAAM,EAAI,EAArB,CAA1B,CACA,GAAMK,SAAQ,CAAGlB,QAAQ,CAAC,QAAD,CAAWc,KAAK,EAAI,EAApB,CAAzB,CAEA,GAAIR,qBAAqB,CAACK,KAAD,CAAzB,CAAkC,CAChC,MAAO,KAAP,CACD,CACD,MACEd,qBAACU,GAAD,aACMS,aADN,EAYED,IAAI,CAAEA,IAZR,CAaED,KAAK,CAAEI,QAbT,CAcEL,MAAM,CAAEI,SAdV,CAeEL,SAAS,CAAEA,SAfb,CAgBEO,iBAAiB,CAAC,OAhBpB,CAkBEV,GAAG,CAAEA,GAlBP,GAoBGZ,KAAK,CAACuB,QAANvB,CAAewB,KAAfxB,CAAqBa,QAArBb,EAAiC,CAAjCA,CACCA,oBAACO,CAAD,MACGP,KAAK,CAACuB,QAANvB,CAAeyB,GAAfzB,CAAmBa,QAAnBb,CAA6B,SAAC0B,KAAD,CAAQC,CAAR,uBAC5B3B,qBAAC4B,SAAD,WACEC,GAAG,aAAEH,KAAF,OAAEA,OAAF,SAAEA,CAAF,MAAEA,MAAK,CAAEG,GAAT,yCAAgBF,CADrB,CAEEG,OAAO,CAAEJ,KAFX,EAGMA,KAHN,OAGMA,OAHN,SAGMA,CAHN,MAGMA,MAAK,CAAEZ,KAHb,EAD4B,CAA7B,EADH,CADDd,CAWCQ,uBA/BJ,CADF,CAdF,EAmDA,GAAMoB,UAAS,CAAG,QAAZA,UAAY,OAAgD,IAA7CE,QAA6C,OAA7CA,OAA6C,CAApCC,IAAoC,OAApCA,IAAoC,CAAtBC,UAAsB,OAA9BhB,MAA8B,CAChE,GAAMiB,gBAAe,CAAG9B,QAAQ,CAAC,QAAD,CAAW6B,UAAU,EAAI,EAAzB,CAAhC,CACA,GAAME,UAAS,CAAG/B,QAAQ,CAAC,QAAD,CAAW4B,IAAI,EAAI,EAAnB,CAA1B,CAEA,GAAI,CAACD,OAAL,CAAc,CACZ,MAAO,KAAP,CACD,CAED,MAAO9B,MAAK,CAACmC,YAANnC,CAAmB8B,OAAnB9B,CAA4B,CACjC+B,IAAI,CAAEG,SAAS,CAAGA,SAAH,CAAe,cADG,CAEjClB,MAAM,CAAEiB,eAFyB,CAA5BjC,CAAP,CARF,EAaA,cAAeC,KAAI,CAACC,UAAU,CAACS,OAAD,CAAX,CAAnB","names":["React","memo","forwardRef","useToken","usePropsResolution","makeStyledComponent","Svg","G","questionOutlineIconPath","useHasResponsiveProps","SVG","SVGIcon","ref","children","props","focusable","stroke","color","size","resolvedProps","strokeHex","colorHex","accessibilityRole","Children","count","map","child","i","ChildPath","key","element","fill","pathStroke","pathStrokeColor","fillColor","cloneElement"],"sources":["SVGIcon.tsx"],"sourcesContent":["import React, { memo, forwardRef } from 'react';\nimport { useToken, usePropsResolution } from '../../../hooks';\nimport { makeStyledComponent } from '../../../utils/styled';\nimport { Svg, G } from './nbSvg';\nimport type { IIconProps } from './types';\nimport { questionOutlineIconPath } from './Icons/questionIconPath';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst SVG = makeStyledComponent(Svg);\n\nconst SVGIcon = ({ children, ...props }: IIconProps, ref: any) => {\n  const {\n    focusable,\n    stroke,\n    color,\n    size,\n    ...resolvedProps\n  } = usePropsResolution('Icon', props);\n  const strokeHex = useToken('colors', stroke || '');\n  const colorHex = useToken('colors', color || '');\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(props)) {\n    return null;\n  }\n  return (\n    <SVG\n      {...resolvedProps}\n      // height={\n      //   newProps.size\n      //     ? parseInt(newProps.size, 10)\n      //     : parseInt(newProps.height, 10)\n      // }\n      // width={\n      //   newProps.size\n      //     ? parseInt(newProps.size, 10)\n      //     : parseInt(newProps.width, 10)\n      // }\n      size={size}\n      color={colorHex}\n      stroke={strokeHex}\n      focusable={focusable}\n      accessibilityRole=\"image\"\n      // style={style}\n      ref={ref}\n    >\n      {React.Children.count(children) > 0 ? (\n        <G>\n          {React.Children.map(children, (child, i) => (\n            <ChildPath\n              key={child?.key ?? i}\n              element={child}\n              {...child?.props}\n            />\n          ))}\n        </G>\n      ) : (\n        questionOutlineIconPath\n      )}\n    </SVG>\n  );\n};\nconst ChildPath = ({ element, fill, stroke: pathStroke }: any) => {\n  const pathStrokeColor = useToken('colors', pathStroke || '');\n  const fillColor = useToken('colors', fill || '');\n\n  if (!element) {\n    return null;\n  }\n\n  return React.cloneElement(element, {\n    fill: fillColor ? fillColor : 'currentColor',\n    stroke: pathStrokeColor,\n  });\n};\nexport default memo(forwardRef(SVGIcon));\n"]},"metadata":{},"sourceType":"module"}