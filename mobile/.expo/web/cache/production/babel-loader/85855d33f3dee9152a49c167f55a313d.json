{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import{CodedError}from'expo-modules-core';import ExpoFontLoader from\"./ExpoFontLoader\";import{FontDisplay}from\"./Font\";function uriFromFontSource(asset){if(typeof asset==='string'){return asset||null;}else if(typeof asset==='object'){return asset.uri||asset.localUri||null;}return null;}function displayFromFontSource(asset){return asset.display||FontDisplay.AUTO;}export function fontFamilyNeedsScoping(name){return false;}export function getAssetForSource(source){var uri=uriFromFontSource(source);var display=displayFromFontSource(source);if(!uri||typeof uri!=='string'){throwInvalidSourceError(uri);}return{uri:uri,display:display};}function throwInvalidSourceError(source){var type=typeof source;if(type==='object')type=JSON.stringify(source,null,2);throw new CodedError(\"ERR_FONT_SOURCE\",\"Expected font asset of type `string | FontResource | Asset` (number is not supported on web) instead got: \"+type);}export function loadSingleFontAsync(_x,_x2){return _loadSingleFontAsync.apply(this,arguments);}function _loadSingleFontAsync(){_loadSingleFontAsync=_asyncToGenerator(function*(name,input){if(typeof input!=='object'||typeof input.uri!=='string'||input.downloadAsync){throwInvalidSourceError(input);}yield ExpoFontLoader.loadAsync(name,input);});return _loadSingleFontAsync.apply(this,arguments);}export function getNativeFontName(name){return name;}","map":{"version":3,"mappings":"uEACA,OAASA,UAAT,KAA2B,mBAA3B,CAEA,MAAOC,eAAP,wBACA,OAASC,WAAT,cAGA,QAASC,kBAAT,CAA2BC,KAA3B,CAAqC,CACnC,GAAI,MAAOA,MAAP,GAAiB,QAArB,CAA+B,CAC7B,MAAOA,MAAK,EAAI,IAAhB,CACD,CAFD,IAEO,IAAI,MAAOA,MAAP,GAAiB,QAArB,CAA+B,CACpC,MAAOA,MAAK,CAACC,GAAN,EAAaD,KAAK,CAACE,QAAnB,EAA+B,IAAtC,CACD,CACD,MAAO,KAAP,CACD,CAED,QAASC,sBAAT,CAA+BH,KAA/B,CAAyC,CACvC,MAAOA,MAAK,CAACI,OAAN,EAAiBN,WAAW,CAACO,IAApC,CACD,CAED,MAAM,SAAUC,uBAAV,CAAiCC,IAAjC,CAA6C,CACjD,MAAO,MAAP,CACD,CAED,MAAM,SAAUC,kBAAV,CAA4BC,MAA5B,CAA8C,CAClD,GAAMR,IAAG,CAAGF,iBAAiB,CAACU,MAAD,CAA7B,CACA,GAAML,QAAO,CAAGD,qBAAqB,CAACM,MAAD,CAArC,CAEA,GAAI,CAACR,GAAD,EAAQ,MAAOA,IAAP,GAAe,QAA3B,CAAqC,CACnCS,uBAAuB,CAACT,GAAD,CAAvB,CACD,CAED,MAAO,CACLA,GAAG,CAAEA,GADA,CAELG,OAAO,CAAPA,OAFK,CAAP,CAID,CAED,QAASM,wBAAT,CAAiCD,MAAjC,CAA4C,CAC1C,GAAIE,KAAI,CAAW,MAAOF,OAA1B,CACA,GAAIE,IAAI,GAAK,QAAb,CAAuBA,IAAI,CAAGC,IAAI,CAACC,SAAL,CAAeJ,MAAf,CAAuB,IAAvB,CAA6B,CAA7B,CAAP,CACvB,KAAM,IAAIb,WAAJ,gIAE2Ge,IAF3G,CAAN,CAID,CAED,eAAsBG,oBAAtB,4D,uEAAO,UACLP,IADK,CAELQ,KAFK,CAEsB,CAE3B,GAAI,MAAOA,MAAP,GAAiB,QAAjB,EAA6B,MAAOA,MAAK,CAACd,GAAb,GAAqB,QAAlD,EAA+Dc,KAAa,CAACC,aAAjF,CAAgG,CAC9FN,uBAAuB,CAACK,KAAD,CAAvB,CACD,CAED,KAAMlB,eAAc,CAACoB,SAAf,CAAyBV,IAAzB,CAA+BQ,KAA/B,CAAN,CACD,C,qDAED,MAAM,SAAUG,kBAAV,CAA4BX,IAA5B,CAAwC,CAC5C,MAAOA,KAAP,CACD","names":["CodedError","ExpoFontLoader","FontDisplay","uriFromFontSource","asset","uri","localUri","displayFromFontSource","display","AUTO","fontFamilyNeedsScoping","name","getAssetForSource","source","throwInvalidSourceError","type","JSON","stringify","loadSingleFontAsync","input","downloadAsync","loadAsync","getNativeFontName"],"sourceRoot":"","sources":["../src/FontLoader.web.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { CodedError } from 'expo-modules-core';\n\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontDisplay } from './Font';\nimport { FontResource, FontSource } from './Font.types';\n\nfunction uriFromFontSource(asset: any): string | null {\n  if (typeof asset === 'string') {\n    return asset || null;\n  } else if (typeof asset === 'object') {\n    return asset.uri || asset.localUri || null;\n  }\n  return null;\n}\n\nfunction displayFromFontSource(asset: any): FontDisplay | undefined {\n  return asset.display || FontDisplay.AUTO;\n}\n\nexport function fontFamilyNeedsScoping(name: string): boolean {\n  return false;\n}\n\nexport function getAssetForSource(source: FontSource): Asset | FontResource {\n  const uri = uriFromFontSource(source);\n  const display = displayFromFontSource(source);\n\n  if (!uri || typeof uri !== 'string') {\n    throwInvalidSourceError(uri);\n  }\n\n  return {\n    uri: uri!,\n    display,\n  };\n}\n\nfunction throwInvalidSourceError(source: any): never {\n  let type: string = typeof source;\n  if (type === 'object') type = JSON.stringify(source, null, 2);\n  throw new CodedError(\n    `ERR_FONT_SOURCE`,\n    `Expected font asset of type \\`string | FontResource | Asset\\` (number is not supported on web) instead got: ${type}`\n  );\n}\n\nexport async function loadSingleFontAsync(\n  name: string,\n  input: Asset | FontResource\n): Promise<void> {\n  if (typeof input !== 'object' || typeof input.uri !== 'string' || (input as any).downloadAsync) {\n    throwInvalidSourceError(input);\n  }\n\n  await ExpoFontLoader.loadAsync(name, input);\n}\n\nexport function getNativeFontName(name: string): string {\n  return name;\n}\n"]},"metadata":{},"sourceType":"module"}